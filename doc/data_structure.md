数据结构
=================
分为逻辑结构和物理结构

### 逻辑结构
-----------------
是指数据对象中数据元素之间的相互关系

1. 集合结构, 改结构的数据元素都属于一个集合
2. 线性结构, 数据元素之间是一对一的关系
3. 树形结构, 数据元素之间存在一种一对多的层次关系
4. 图形结构, 数据元素之间是多对多的关系

### 物理结构
-----------------
是指数据的逻辑结构在计算机中的存储形式, 存储器主要是针对内存而言,
硬盘,软盘,光盘等外部存储器的数据结构通常用文件结构来描述

1. 顺序存储结构, 把数据元素存放在地址连续的存储单元里,其数据间的逻辑关系和物理关系是一致的.  编程的数组结结构就是顺序存储结构.
2. 链式存储, 把数据元素存放在任意的存储单元里, 这组存储单元可以是连续的,也可以不连续, 需要一个指针来存放数据元素的地址, 这样可以通过地址来找到相关联数据元素的位置.

### 算法
-----------------
是解决特定问题求解步骤的描述, 在计算机中表现为指令的有限序列, 并且每条指令表示一个或多个操作.

基本特征
1. 输入, 算法具有0 个 或者多个输入
2. 输出, 算法至少有1个或者多个输出. 形式可以是打印形式输出, 也可以是返回一个值或者多个值等.
3. 有穷性, 指算法在执行有限的步骤之后, 自动结束而不会出现无线循环,并且每个步骤在可接受的时间内完成.
4. 确定性, 算法的每个步骤都具有特定的含义, 不会出现二义性(多个含义), 算法在一定条件下,
    只有一条执行路径, 相同的输入只能有唯一的输出结果, 算法的每个步骤都应该被精确定义而无歧义.
5. 可行性,. 算法的每一步都必须是可行的, 每一步都能够通过执行有限次数完成.

### 算法的正确性
-----------------
正确性, 指算法至少应该具有输入,输出和加工处理无歧义性,能正确反映问题的需求,能够得到问题的正确答案.
1. 算法程序没有语法错误
2. 算法程序对于合法输入能够产生满足需求的输出
3. 算法程序对于非法输入能够产生满足规格的说明
4. 算法程序对于故意刁难的测试输入都有满足需求的输出结果

可读性, 为了阅读,理解和交流
健壮性, 当输入数据不合法时,算法也能作出相关处理,而不是产生异常,崩溃或者莫名其妙的结果
时间效率高和存储量低(内存占用).

### 算法效率的度量
------------------
事前分析估算方法, 在计算机程序编写前,依据统计方法对算法进行估算.
1. 算法采用的策略,方案
2. 编译产生的代码质量
3. 问题的输入规模(输入量的多少)
4. 机器执行指令的速度
int i, sum =0, n = 100; // 执行1次
for( i=1; i <= n; i++ ) //执行了n+1次
{
    sum = sum + i;      //执行n次
}
共执行了1+ (n+1) + n = 2n +2 次

第二种算法
int sum = 0; n = 100; //执行1次
sum = (1+n)*n/2        // 执行1次
共执行了1+1 = 2 次

如果把循环看作一个整体, 忽略头尾判断的开销, 那么这两个算法其实就是n和1的差距. 因为循环判断在算法1里执行了n+1次
int i, j, x=0, sum=0, n=100;
for( i=1; i <= n; i++ )
{
    for( j=1; j <= n; j++)
    {
        x++;
        sum = sum + x;
    }
}
循环条件i 从1到100, 每次让j循环100次. 
算法的复杂度, 侧重的是研究算法随着输入规模扩展增长量的一个抽象, 而不是抽象定位需要执行多少次. 故上面例子可以判断需要执行100^2 次. 
这样, 不计算循环索引的递增和循环终止条件, 变量声明, 打印结果等操作. 最终在分析程序的运行时间时, 最重要的是把程序堪称是独立与程序设计语言的算法或一系列步骤.
故而,在分析一个算法的运行时间时,重要的是把基本操作的数量和输入模式关联起来.

函数的渐近增长. 给定两个函数f(n) 和g(n), 如果存在一个整数N, 使得对于所有的n>N, f(n)总是比g(n)大, 那么我们就说f(n)的增长渐近快于g(n)
随着n的增大, 后面的+3, +1  已经不在影响最终的算法变化曲线了, 所以可以忽略这些加减法常数
与最高次项相乘的常数也不影响算法的渐近增长规模, 也可以忽略. 2n的2, 3n的3
最高次项的指数大的, 函数随着n的增长, 结果也会变得增长特别快
判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略, 更应该关注主项(最高项)的阶数, 同时需要一定规模才能判断出来算法的好坏

规模, 算法  A1(2n+3)   A2(2n)  B1(3n+1) B2(3n)
n=1             5       2       4       3 
n=2             7       4       7       6 
n=3             9       6       10      9 
n=10            23      20      31      30 
n=100           203     200     301     300 
总体上A1 随着规模增大就比B1 效率高了.

次数 算法   G 2n^2,     H 3n+1,     I是 2n^2+3n+1
1           20          4           6 
2           8           7           15 
5           50          16          66 
10          200         31          231 
100         2000        301         20301 
1000        2000000     3001        200301 
10000       200000000   30001       200030001 
100000      20000000000 300001      20000300001





